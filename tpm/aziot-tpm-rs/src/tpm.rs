// Copyright (c) Microsoft. All rights reserved.

use std::convert::AsRef;
use std::ops::{Deref, Drop};
use std::os::raw::{c_uchar, c_void};
use std::ptr;
use std::slice;

use super::{ManageTpmKeys, SignWithTpm};
use crate::error::Error;
use aziot_tpm_sys::{
    hsm_client_tpm_activate_identity_key, hsm_client_tpm_create, hsm_client_tpm_deinit,
    hsm_client_tpm_destroy, hsm_client_tpm_free_buffer, hsm_client_tpm_get_endorsement_key,
    hsm_client_tpm_get_storage_key, hsm_client_tpm_init, hsm_client_tpm_sign_data,
    HSM_CLIENT_HANDLE,
};

/// Hsm for TPM
///
/// Create an instance of this to use the TPM interface of an HSM.
#[derive(Debug)]
pub struct Tpm {
    handle: HSM_CLIENT_HANDLE,
}

// SAFETY: Handles don't have thread-affinity
unsafe impl Send for Tpm {}

macro_rules! tpm_buffer_newtype {
    (
        $(#[$attr:meta])*
        pub struct $newtype:ident(TpmBuffer)
    ) => {
        $(#[$attr])*
        pub struct $newtype(TpmBuffer);

        impl Deref for $newtype {
            type Target = [u8];
            fn deref(&self) -> &Self::Target {
                self.0.deref()
            }
        }

        impl AsRef<[u8]> for $newtype {
            fn as_ref(&self) -> &[u8] {
                self.0.as_ref()
            }
        }
    };
}

tpm_buffer_newtype!(
    /// A key generated by the TPM.
    /// Dereferences to a `[u8]`, and implements `AsRef<[u8]>`.
    pub struct TpmKey(TpmBuffer)
);

tpm_buffer_newtype!(
    /// A digest generated by the TPM.
    /// Dereferences to a `[u8]`, and implements `AsRef<[u8]>`.
    pub struct TpmDigest(TpmBuffer)
);

impl Drop for Tpm {
    fn drop(&mut self) {
        unsafe {
            hsm_client_tpm_destroy(self.handle);
        }
        // TODO: unit tests are calling this function, and should avoid doing so.
        unsafe { hsm_client_tpm_deinit() };
    }
}

impl Tpm {
    /// Create a new TPM implementation for the HSM API.
    pub fn new() -> Result<Tpm, Error> {
        let result = unsafe { hsm_client_tpm_init() as isize };
        if result != 0 {
            return Err(Error::Init(result));
        }
        let handle = unsafe { hsm_client_tpm_create() };
        if handle.is_null() {
            unsafe { hsm_client_tpm_deinit() };
            return Err(Error::NullResponse);
        }
        Ok(Tpm { handle })
    }
}

impl ManageTpmKeys for Tpm {
    /// Imports key that has been previously encrypted with the endorsement key and storage root key into the TPM key storage.
    fn activate_identity_key(&self, key: &[u8]) -> Result<(), Error> {
        let result =
            unsafe { hsm_client_tpm_activate_identity_key(self.handle, key.as_ptr(), key.len()) };
        match result {
            0 => Ok(()),
            r => Err(r.into()),
        }
    }

    /// Retrieves the endorsement key of the TPM .
    fn get_ek(&self) -> Result<TpmKey, Error> {
        let mut key_ln: usize = 0;
        let mut ptr = ptr::null_mut();

        let result =
            unsafe { hsm_client_tpm_get_endorsement_key(self.handle, &mut ptr, &mut key_ln) };
        match result {
            0 => Ok(TpmKey(TpmBuffer::new(ptr as *const _, key_ln))),
            r => Err(r.into()),
        }
    }

    /// Retrieves the storage root key of the TPM
    fn get_srk(&self) -> Result<TpmKey, Error> {
        let mut key_ln: usize = 0;
        let mut ptr = ptr::null_mut();

        let result = unsafe { hsm_client_tpm_get_storage_key(self.handle, &mut ptr, &mut key_ln) };
        match result {
            0 => Ok(TpmKey(TpmBuffer::new(ptr as *const _, key_ln))),
            r => Err(r.into()),
        }
    }
}

impl SignWithTpm for Tpm {
    /// Hashes the parameter data with the key previously stored in the TPM and returns the value
    fn sign_with_identity(&self, data: &[u8]) -> Result<TpmDigest, Error> {
        let mut key_ln: usize = 0;
        let mut ptr = ptr::null_mut();

        let result = unsafe {
            hsm_client_tpm_sign_data(
                self.handle,
                data.as_ptr(),
                data.len(),
                &mut ptr,
                &mut key_ln,
            )
        };
        match result {
            0 => Ok(TpmDigest(TpmBuffer::new(ptr as *const _, key_ln))),
            r => Err(r.into()),
        }
    }
}

/// When buffer data is returned from TPM interface, it is placed in this struct.
/// This is a buffer allocated by the C library.
#[derive(Debug)]
pub struct TpmBuffer {
    key: *const c_uchar,
    len: usize,
}

impl Drop for TpmBuffer {
    fn drop(&mut self) {
        unsafe { hsm_client_tpm_free_buffer(self.key as *mut c_void) };
    }
}

impl TpmBuffer {
    pub fn new(key: *const c_uchar, len: usize) -> TpmBuffer {
        TpmBuffer { key, len }
    }
}

impl Deref for TpmBuffer {
    type Target = [u8];
    fn deref(&self) -> &Self::Target {
        self.as_ref()
    }
}

impl AsRef<[u8]> for TpmBuffer {
    fn as_ref(&self) -> &[u8] {
        unsafe { slice::from_raw_parts(self.key, self.len) }
    }
}
