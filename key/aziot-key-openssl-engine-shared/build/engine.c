/* Copyright (c) Microsoft. All rights reserved. */

#include <openssl/engine.h>

int aziot_key_openssl_engine_shared_bind(ENGINE* e, const char* id);

/**
 * The openssl engine API uses two macros - IMPLEMENT_DYNAMIC_BIND_FN and IMPLEMENT_DYNAMIC_CHECK_FN - to register the engine's entrypoint.
 *
 * The underlying bind function that the macros expand to are not stable across openssl versions, so it's not easy to invoke them directly from Rust.
 * Therefore we use the macros in this C file.
 *
 * There is one more problem however. When compiling the cdylib, rustc uses a version script that only lists globals that rustc knows about.
 * So the bind_engine and v_check functions generated by these two macros will not actually be exported by the final cdylib. It's not possible
 * to provide a custom version script via `cargo:rustc-cdylib-link-arg` because it conflicts with the one generated by rustc.
 *
 * So we have to use the other way mentioned by `ld`'s docs[1], `__asm__(".symver")`. We also need to add `__attribute__((used))` since otherwise
 * the versioned symbol is optimized out by LTO.
 *
 * Unfortunately this trick means this crate cannot be compiled for tests since the linker will see duplicate symbols, so every invocation of
 * `cargo test --all` or `cargo clippy --tests --all` has to also exclude this crate with `--exclude`. When all of our platforms provide
 * GNU as >= 2.35 and/or Clang >= 13, we can lift this restriction by appending `,remove` to the `.symver` directive arguments[2].
 *
 * [1]: https://sourceware.org/binutils/docs/ld/VERSION.html
 * [2]: https://maskray.me/blog/2020-11-26-all-about-symbol-versioning
 */
__attribute__((used))
IMPLEMENT_DYNAMIC_BIND_FN(aziot_key_openssl_engine_shared_bind);
__asm__(".symver bind_engine,bind_engine@@");
__attribute__((used))
IMPLEMENT_DYNAMIC_CHECK_FN();
__asm__(".symver v_check,v_check@@");
